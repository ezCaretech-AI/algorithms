# 기초적인 탐색 알고리즘

## 1. 순차 탐색(sequential search)

### 1.1. 이론적 배경

> 1. 배열에 순서 없이 저장되어 있는 리스트를 탐색

> 2. 첫번째 레코드부터 시작하여 마지막 레코드까지 차례로 탐색키를 비교하여 탐색 키와 같은 키 값을 가지는 레코드가 있으면 이것을 반환

> 3. 단방향으로 탐색을 수행하기 때문에 선형 탐색(Linear Search)라고도 함.

### 1.2. 특 징

> 데이터를 따로 조작할 필요가 없어 단순하다는 장점이 있지만, 찾는 값이 리스트의 뒤쪽에 있다면 탐색이 많아져서 비효율적이다.

## 1.3. 탐색 과정

![Alt text](/imgs/search/sequential_search.JPG)

### 1.4. 복잡도

![Alt text](/imgs/search/sequential_search1.JPG)

> 시간복잡도는 : O(n)

-----------------------------------------

## 2. 이진 탐색

### 2.1. 이론적 배경

> 1. 이미 데이터가 정렬되어 있는 리스트에서 특정한 값을 찾아내는 알고리즘  
> 2. 리스트의 중간값과 비교하여 탐색 키가 중간값보다 작으만 왼쪽 절반에 대하, 크면 오른쪽 절반에 대한 탐색

### 2.2. 탐색 과정

![Alt text](/imgs/search/binary_search.JPG)

### 2.3. 시간 복잡도

* 탐색을 반복할 때마다 탐색 범위를 반으로 줄인다. 이러한 탐색 범위가 더 이상 줄일 수 없는 1이 될 때의 탐색 횟수를 k라 한다면

![Alt text](/imgs/search/binary_search2.JPG)

-------------------------------------------

## 3. 이진탐색트리

### 3.1. 이론적 배경

> 1. 이진탐색이 적용된 이진트리구조  
> 2. 주어진 자료를 이진 탐색 트리로 변환하여 탐색을 수행.
> 3. 이진탐색의 효율적인 탐색능력을 유지하면서도, 빈번한 삽입과 삭제를 가능하게끔 고안.

### 3.2. 특징

> 1. 왼쪽 서브트리의 키들은 루트의 키보다 작다.  
> 2. 오른쪽 서브트리의 키들은 루트의 키보다 크다.  
> 3. 중복된 데이터를 갖는 노드는 없다.  
> 4. 왼쪽과 오른쪽 서브트리도 이진 탐색트리다.

![Alt text](/imgs/search/tree_search.JPG)

### 3.3. 탐색 알고리즘

> 1. 루트 노드의 키와 찾고자 하는 값을 비교.  
> 2. 찾고자 하는 값이 루트 노드의 키 값보다 작으면, 탐색은 루트노드 기준으로 왼쪽 서브트리로 이동하여 다시 탐색.  
> 3. 찾고자 하는 값이 루트 노드의 키 값보다 크면, 탐색은 루트노드 기준으로 오른쪽 서브트리로 이동하여 다시 탐색.  
> 4. 찾고자 하는 값을 찾으면 탐색 종료.

![Alt text](/imgs/search/tree_search1.JPG)

### 3.4. 삽입 알고리즘

> 1. 전체 노드를 탐색 후에, 찾고자 하는 값이 없는 경우 해당 위치에 값을 삽입.  
> 2. 결과적으로 탐색을 실패한 위치에 새로운 노드를 삽입하는 알고리즘.

![Alt text](/imgs/search/tree_search2.JPG)

### 3.6. 복잡도

> 트리의 높이만큼의 시간의 소요되므로 탐색의 시간 복잡도는 O(h) (h=트리의높이)

